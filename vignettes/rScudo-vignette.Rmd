---
title: "An introduction to rScudo"
date: "`r Sys.Date()`"
author:
-   name: Matteo Ciciani
    affiliation: &aff CIBIO, Univ. of Trento, Trento, Italy
    email: matteo.ciciani@gmail.com
-   name: Thomas Cantore
    affiliation: *aff
output:
    BiocStyle::pdf_document:
        #toc_float: true
vignette: >
    %\VignetteIndexEntry{Signature-based Clustering for Diagnostic Purposes}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

# Introduction

This package implements in R the SCUDO pipeline proposed in Lauria (2013) and
Lauria, Moyseos, Priami (2015).

SCUDO is a method for the analysis of gene expression profiles for diagnostic
and classification purposes. The method is based on the idea of
sample-specific gene signatures. The expected result is the emergence of a
partitioning of the set of samples in separate clusters (propely, communities)
on the basis of signature similarity.

# Methods in brief

Starting from gene expression data, the function `scudoTrain` performs the basic
SCUDO pipeline and can be used to generate an object of class `scudoResults`,
which contains sample specific gene signatures and consensus gene signatures for
each group specified. The pipeline impemented by this function can be sumarized
in 4 steps:

1. First, fold-changes are computed for each gene. Then, a feature selection
step is performed. The user can specify whether to use a parametric or a non
parametric test. The test used also depends on the number of groups present in
the dataset. This step can be optionally skipped.

2. The subsequent operations include single sample gene ranking and the
extraction of signatures formed by up-regulated and down-regulated genes. The
length of the signatures are customizable. Consensus signtures are then
computed, both for up- and down-regulated genes and for each group. The
computation of consensus signatures is performed aggregating the ranks of the
genes in each sample and ranking again the genes.

3. An all-to-all distance matrix is then computed using a distance similar to
the Gene Set Enrichment Analysis (GSEA): the distance between two samples is
computed as the mean of the enrichment scores (ES) of the signature of each
sample in the expression profile of the other sample. The distance function used
is customizable.

4. Finally, a user-defined threshold N is used to generate a network of samples.
The distance matrix is treated as an adjacency matrix, but only the distances
that fall below the N^th^ quantile of distances are used to draw edges in the
network. This is performed by the function `scudoNetwork`.The network can then
be displayed in R or using Cytoscape.

After the identification of a list of genes that can be used to partition the
samples in separated communities, the same procedure can be applied to a testig
dataset. The function `scudoTest` performs steps 2 and 3 on a testing dataset,
taking into account only the genes selected in the training dataset.

Alteranatively, a supervised classification procedure can be applied, using the
function `scudoClassify`. This function takes as input a training set,
containing samples with known classification, and a testing set of samples with
unknown classification. For each sample in the testing set, the function computes a network formed by all the samples in the training set and a single sample from the training set. Then a classification score is generated for each testing sample, using an approach

# Example workflow of rScudo

## Data preparation

In this example we will use the `r Biocpkg("ALL")` dataset, containing gene
expression data from T- and B-cells acute lymphocytic leukemia patients. In this
first part, we are interested in distinguishing B-cells and T-cells samples,
based on gene expression profiles. We begin by loading relevant libraries and
subsetting the dataset, dividing it in a training and a testing set.

```{r, message=FALSE}
library(rScudo)
library(igraph)
library(ALL)
data(ALL)

bt <- as.factor(stringr::str_extract(pData(ALL)$BT, "^."))
summary(bt)

set.seed(1)
inTrain <- c(sample(1:95, 47), sample(96:128, 16))
trainData <- ALL[, inTrain]
testData <- ALL[, -inTrain]
```

## Analysis of the training set

We start by analyzing the training set. We first run `scudoTrain`, which returns
an object of class `ScudoResults`.

```{r}
trainRes <- scudoTrain(trainData, groups = bt[inTrain], nTop = 100,
    nBottom = 100, alpha = 0.1)
trainRes
```

From this object we can extract the signatures for each sample and the consensus
signatures for each group.

```{r}
upSignatures(trainRes)[1:5,1:5]
consensusUpSignatures(trainRes)[1:5, ]
```

The object `trainRes` can be used to generate a network of samples, using the
function `ScudoNetwork`. This function returns an `r CRANpkg("igraph")` object.
The parameter `N` controls the percentage of edges to keep in the network. We
can plot this network using the function `scudoPlot`.

```{r}
trainNet <- scudoNetwork(trainRes, N = 0.2)
scudoPlot(trainNet, vertex.label = NA)
```

You can also render the network in Cytoscape, using the function
`ScudoCytoscape`. Note that Cytoscape has to be open when running the function.

```{r, eval=FALSE}
scudoCytoscape(netTrain)
```

Since we obtained a very good separation of the two groups, we proceed to
analyze the testing set.

## Analysis of the testing set

We can use a `ScudoResults` object and the function `scudoTest` to analyze the
testing set. The feature selection is not performed in the testing set. Instead,
only the features selected in the training are used in the analysis of the
testing set.

```{r}
testRes <- scudoTest(trainRes, testData, bt[-inTrain], nTop = 100,
    nBottom = 100)
testRes
```

We can generate a network of samples and plot it.

```{r}
testNet <- scudoNetwork(testRes, N = 0.2)
scudoPlot(testNet, vertex.label = NA)
```

We can use a community clustering algorithm to identify clusters of samples. In
the following example we use the function `cluster_spinglass` to perform a
greedy clustering of our network. In Cytoscape we can perform a similar analysis
using the clustering functions from the clusterMaker app.

```{r}
testClust <- cluster_spinglass(testNet, spins = 2)
plot(testClust, testNet, vertex.label = NA)
```

### Supervised classification

`scudoClassify` performs supervised classification of sample in a testing set
using a model built from samples in a training set. It uses a method based on
neighbors in the graph to assign a class label to each sample in the testing
set. We suggest to use the same `N`, `nTop`, `nBottom` and `alpha` that were
used in the trainig step.

```{r}
classRes <- scudoClassify(trainData, testData, N = 0.2, nTop = 100,
    nBottom = 100, trainGroups = bt[inTrain], alpha = 0.1)
classRes$predicted
```

Classification performances can be explored using the `confusionMatrix` function
from `r CRANpkg("caret")`.

```{r}
caret::confusionMatrix(classRes$predicted, bt[-inTrain])
```

## Example of multigroup analysis

```{r}
typeB <- which(as.character(ALL$BT) %in% c("B1", "B2", "B3"))
ALLB <- ALL[, typeB]
type <- ALLB$BT[, drop = TRUE]
table(type)

molBiol <- factor(ALLB$mol.biol)

inTrain <- as.vector(caret::createDataPartition(type, p = 0.6, list = FALSE))
```

```{r}
res <- scudoTrain(ALLB[, inTrain], type[inTrain], 50, 50, 0.01)
net <- scudoNetwork(res, 0.2)
scudoPlot(net, vertex.label = NA)
```

```{r}
resTest <- scudoTest(res, ALLB[, -inTrain], type[-inTrain])
netTest <- scudoNetwork(resTest, 0.2)
scudoPlot(netTest, vertex.label = NA)
```

```{r}
classRes <- scudoClassify(ALLB[, inTrain], ALLB[, -inTrain], 0.99, 50, 50,
    type[inTrain], alpha = 0.01)
caret::confusionMatrix(classRes$predicted, type[-inTrain])
```

# Session info

```{r}
sessionInfo()
```

# References

Mario Lauria. Rank-based transcriptional signatures. Systems Biomedicine. 2013;
1(4):228-239.

Mario Lauria, Petros Moyseos and Corrado Priami. SCUDO: a tool for
signature-based clustering of expression profiles. Nucleic Acids Research. 2015;
43(W1):W188-92.
